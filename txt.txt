# [End of Step 5 code - after the print statements]
# ... (code from step 5 finishes here)
print("-" * 30)


# =============================================================================
# --- 5b. ניתוח קורלציה בין חלונות (אופציונלי, לניתוח בלבד) ---
# =============================================================================
print("\n--- 5b. Analyzing Window Correlations (Optional Analysis Step) ---")

# Configuration for window correlation analysis
NUM_PAIRS_TO_ANALYZE_PER_COMPARISON = 100 # How many random pairs to check for each comparison type
ANALYZE_WINDOW_CORRELATIONS = True       # Set to False to skip this analysis block entirely

if ANALYZE_WINDOW_CORRELATIONS and all_windows and all_window_labels:
    print(f"Analyzing correlations between windows (sampling {NUM_PAIRS_TO_ANALYZE_PER_COMPARISON} pairs per comparison type)...")

    # Prepare data: Create a dictionary mapping labels to window indices
    indices_by_label = {}
    unique_analysis_labels = sorted(list(set(all_window_labels)))
    for label in unique_analysis_labels:
        indices_by_label[label] = [i for i, lbl in enumerate(all_window_labels) if lbl == label]
        print(f"Found {len(indices_by_label[label])} windows for label '{label}'")

    analysis_results = {} # To store correlation results for different comparisons

    # --- 1. Intra-Class Correlation (Within the same label) ---
    print("\n--- Analyzing Intra-Class Correlations ---")
    for label in unique_analysis_labels:
        label_indices = indices_by_label[label]
        if len(label_indices) < 2:
            print(f"Skipping intra-class analysis for '{label}': Not enough windows ({len(label_indices)}).")
            continue

        correlations_within_label = []
        # Generate unique pairs of indices within this label
        possible_pairs = list(itertools.combinations(label_indices, 2))
        if len(possible_pairs) == 0: continue

        # Sample pairs if there are too many
        num_pairs_to_sample = min(NUM_PAIRS_TO_ANALYZE_PER_COMPARISON, len(possible_pairs))
        sampled_pairs_indices = random.sample(range(len(possible_pairs)), num_pairs_to_sample)

        print(f"Analyzing {num_pairs_to_sample} pairs for label '{label}'...")
        for pair_idx in tqdm(sampled_pairs_indices, desc=f"Corr within {label}", leave=False):
             idx1, idx2 = possible_pairs[pair_idx]
             window1 = all_windows[idx1]
             window2 = all_windows[idx2]

             # Use the existing correlation function
             _, _, _, peak_val, _ = calculate_cross_correlation(window1, window2, SAMPLING_RATE)

             if peak_val is not None:
                 correlations_within_label.append(abs(peak_val)) # Store absolute correlation

        analysis_results[f"{label}_vs_{label}"] = correlations_within_label

    # --- 2. Inter-Class Correlation (Between different labels) ---
    print("\n--- Analyzing Inter-Class Correlations ---")
    label_combinations = list(itertools.combinations(unique_analysis_labels, 2))

    for label1, label2 in label_combinations:
        indices1 = indices_by_label[label1]
        indices2 = indices_by_label[label2]

        if not indices1 or not indices2:
            print(f"Skipping inter-class analysis for '{label1}' vs '{label2}': One or both labels have no windows.")
            continue

        correlations_between_labels = []
        num_pairs_to_sample = NUM_PAIRS_TO_ANALYZE_PER_COMPARISON

        print(f"Analyzing {num_pairs_to_sample} pairs for '{label1}' vs '{label2}'...")
        # Sample one index from each label list for each pair
        sampled_indices1 = random.choices(indices1, k=num_pairs_to_sample)
        sampled_indices2 = random.choices(indices2, k=num_pairs_to_sample)

        for idx1, idx2 in tqdm(zip(sampled_indices1, sampled_indices2), total=num_pairs_to_sample, desc=f"Corr {label1} vs {label2}", leave=False):
            window1 = all_windows[idx1]
            window2 = all_windows[idx2]

            _, _, _, peak_val, _ = calculate_cross_correlation(window1, window2, SAMPLING_RATE)

            if peak_val is not None:
                correlations_between_labels.append(abs(peak_val)) # Store absolute correlation

        analysis_results[f"{label1}_vs_{label2}"] = correlations_between_labels

    # --- 3. Print Summary Statistics ---
    print("\n--- Window Correlation Analysis Summary (Absolute Peak Values) ---")
    for comparison_key, corr_values in analysis_results.items():
        if corr_values:
            avg_corr = np.mean(corr_values)
            max_corr = np.max(corr_values)
            min_corr = np.min(corr_values)
            std_corr = np.std(corr_values)
            median_corr = np.median(corr_values)
            count = len(corr_values)
            print(f"* {comparison_key} ({count} pairs):")
            print(f"    Avg: {avg_corr:.3f}, Median: {median_corr:.3f}, Std: {std_corr:.3f}, Min: {min_corr:.3f}, Max: {max_corr:.3f}")
        else:
            print(f"* {comparison_key}: No correlation values calculated (check data or sampling).")

else:
    if not ANALYZE_WINDOW_CORRELATIONS:
        print("Window correlation analysis is disabled (ANALYZE_WINDOW_CORRELATIONS=False).")
    else:
        print("Skipping window correlation analysis: No windows or labels available.")

print("-" * 30)
# =============================================================================
# --- 6. יצירת ספקטוגרמות (Generating Spectrograms) ---
# =============================================================================
# [Start of Step 6 code - the print statement and the loop]
print("\n--- 6. Generating Spectrograms from Windows ---")
# ... (rest of step 6 code follows)
